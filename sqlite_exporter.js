/**
 * SQLite Exporter for Crystalizer Context Curator
 * Exports IndexedDB archive to downloadable SQLite database
 * Uses sql.js for in-browser SQLite generation
 */

class SQLiteExporter {
    constructor() {
        this.sqlJs = null;
        this.initialized = false;
    }

    /**
     * Initialize sql.js library
     */
    async initialize() {
        if (this.initialized) return;
        
        try {
            // Load sql.js from CDN
            this.sqlJs = await initSqlJs({
                locateFile: file => `https://sql.js.org/dist/${file}`
            });
            this.initialized = true;
        } catch (error) {
            console.error('Error initializing sql.js:', error);
            throw error;
        }
    }

    /**
     * Export all chats to SQLite database file
     * @param {Object} options - Export options {platformId, dateFrom, dateTo, tags}
     * @returns {Promise<Blob>} - SQLite database as Blob
     */
    async exportToSQLite(options = {}) {
        try {
            await this.initialize();
            
            // Create new database
            const db = new this.sqlJs.Database();
            
            // Create schema
            this.createSchema(db);
            
            // Get records from IndexedDB
            const records = await storageManager.getAllRecords(options);
            
            // Insert records
            await this.insertRecords(db, records);
            
            // Also export facts if requested
            if (options.includeFacts) {
                await this.exportFacts(db);
            }
            
            // Export database to binary array
            const binaryArray = db.export();
            
            // Close database
            db.close();
            
            // Convert to Blob
            const blob = new Blob([binaryArray], { type: 'application/x-sqlite3' });
            
            return blob;
        } catch (error) {
            console.error('Error exporting to SQLite:', error);
            throw error;
        }
    }

    /**
     * Create database schema
     */
    createSchema(db) {
        // Main chats table
        db.run(`
            CREATE TABLE chats (
                id TEXT PRIMARY KEY,
                platform TEXT NOT NULL,
                platform_name TEXT,
                label TEXT NOT NULL,
                title TEXT,
                snippet TEXT,
                full_content TEXT,
                timestamp INTEGER,
                url TEXT,
                tags TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Create indexes for better search performance
        db.run('CREATE INDEX idx_platform ON chats(platform)');
        db.run('CREATE INDEX idx_label ON chats(label)');
        db.run('CREATE INDEX idx_timestamp ON chats(timestamp)');
        
        // Full-text search virtual table
        db.run(`
            CREATE VIRTUAL TABLE chats_fts USING fts5(
                label,
                title,
                snippet,
                full_content,
                content=chats,
                content_rowid=rowid
            )
        `);

        // Facts table
        db.run(`
            CREATE TABLE facts (
                id TEXT PRIMARY KEY,
                chat_id TEXT,
                facts TEXT,
                user_label TEXT,
                timestamp INTEGER,
                session_count INTEGER,
                FOREIGN KEY(chat_id) REFERENCES chats(id)
            )
        `);

        // Metadata table
        db.run(`
            CREATE TABLE metadata (
                key TEXT PRIMARY KEY,
                value TEXT
            )
        `);

        // Insert metadata
        const stmt = db.prepare('INSERT INTO metadata (key, value) VALUES (?, ?)');
        stmt.run(['export_date', new Date().toISOString()]);
        stmt.run(['version', '1.0']);
        stmt.run(['tool', 'Crystalizer Context Curator']);
        stmt.free();
    }

    /**
     * Insert records into database
     */
    insertRecords(db, records) {
        const stmt = db.prepare(`
            INSERT INTO chats (id, platform, platform_name, label, title, snippet, full_content, timestamp, url, tags)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);

        for (const record of records) {
            stmt.run([
                record.id,
                record.platformId,
                record.platformName,
                record.userLabel,
                record.autoGeneratedTitle,
                record.contentSnippet,
                record.fullContent,
                record.timestamp,
                record.urlReference,
                JSON.stringify(record.tags)
            ]);
        }

        stmt.free();

        // Populate FTS table
        db.run(`
            INSERT INTO chats_fts(rowid, label, title, snippet, full_content)
            SELECT rowid, label, title, snippet, full_content FROM chats
        `);
    }

    /**
     * Export facts to database
     */
    async exportFacts(db) {
        try {
            const facts = await db.facts.toArray();
            
            const stmt = db.prepare(`
                INSERT INTO facts (id, chat_id, facts, user_label, timestamp, session_count)
                VALUES (?, ?, ?, ?, ?, ?)
            `);

            for (const fact of facts) {
                stmt.run([
                    fact.id,
                    fact.chatId,
                    JSON.stringify(fact.facts),
                    fact.userLabel,
                    fact.timestamp,
                    fact.sessionCount
                ]);
            }

            stmt.free();
        } catch (error) {
            console.error('Error exporting facts:', error);
        }
    }

    /**
     * Download SQLite file
     */
    async downloadDatabase(options = {}) {
        try {
            const blob = await this.exportToSQLite(options);
            
            // Generate filename with timestamp
            const date = new Date().toISOString().split('T')[0];
            const filename = `crystalizer_archive_${date}.db`;
            
            // Create download link
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            return filename;
        } catch (error) {
            console.error('Error downloading database:', error);
            throw error;
        }
    }

    /**
     * Get export preview (record count, size estimate)
     */
    async getExportPreview(options = {}) {
        try {
            const records = await storageManager.getAllRecords(options);
            
            // Estimate size (rough calculation)
            const jsonSize = JSON.stringify(records).length;
            const estimatedDbSize = jsonSize * 1.2; // SQLite overhead
            
            return {
                recordCount: records.length,
                estimatedSize: this.formatBytes(estimatedDbSize),
                estimatedSizeBytes: estimatedDbSize
            };
        } catch (error) {
            console.error('Error getting export preview:', error);
            return null;
        }
    }

    /**
     * Format bytes to human-readable size
     */
    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }
}

// Export singleton instance
const sqliteExporter = new SQLiteExporter();
