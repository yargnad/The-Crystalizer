/**
 * Storage Manager for Crystalizer Context Curator
 * Manages IndexedDB storage for chat archival system
 * Uses Dexie.js wrapper for simplified IndexedDB operations
 */

// Initialize Dexie database
const db = new Dexie('CrystalizerArchive');

db.version(1).stores({
    chats: '++id, platformId, platformName, userLabel, timestamp, tags',
    facts: '++id, chatId, timestamp, sessionCount'
});

class StorageManager {
    constructor() {
        this.quotaWarningThreshold = 0.8; // Warn at 80% usage
    }

    /**
     * Add a new chat record to the archive
     * @param {Object} chatData - The chat data to archive
     * @returns {Promise<string>} - The ID of the created record
     */
    async addChatRecord(chatData) {
        try {
            const record = {
                id: this.generateUUID(),
                platformId: chatData.platformId || 'unknown',
                platformName: chatData.platformName || 'Unknown Platform',
                userLabel: chatData.userLabel, // Required by user
                autoGeneratedTitle: chatData.autoGeneratedTitle || this.extractTitle(chatData.exchanges),
                contentSnippet: this.generateSnippet(chatData.exchanges),
                fullContent: JSON.stringify(chatData.exchanges),
                timestamp: Date.now(),
                urlReference: chatData.urlReference || '',
                tags: chatData.tags || []
            };

            const id = await db.chats.add(record);
            
            // Check quota after adding
            await this.checkQuota();
            
            return id;
        } catch (error) {
            console.error('Error adding chat record:', error);
            throw error;
        }
    }

    /**
     * Search chat records by user label
     * @param {string} labelQuery - The search query for labels
     * @returns {Promise<Array>} - Matching chat records
     */
    async searchByLabel(labelQuery) {
        try {
            const results = await db.chats
                .where('userLabel')
                .startsWithIgnoreCase(labelQuery)
                .toArray();
            
            return results;
        } catch (error) {
            console.error('Error searching by label:', error);
            return [];
        }
    }

    /**
     * Search chat records by content
     * @param {string} contentQuery - The search query for content
     * @returns {Promise<Array>} - Matching chat records
     */
    async searchByContent(contentQuery) {
        try {
            const allChats = await db.chats.toArray();
            const query = contentQuery.toLowerCase();
            
            return allChats.filter(chat => {
                const snippet = chat.contentSnippet.toLowerCase();
                const title = chat.autoGeneratedTitle.toLowerCase();
                const label = chat.userLabel.toLowerCase();
                const content = chat.fullContent.toLowerCase();
                
                return snippet.includes(query) || 
                       title.includes(query) || 
                       label.includes(query) ||
                       content.includes(query);
            });
        } catch (error) {
            console.error('Error searching by content:', error);
            return [];
        }
    }

    /**
     * Get all chat records with optional filtering
     * @param {Object} filters - Optional filters {platformId, dateFrom, dateTo, tags}
     * @returns {Promise<Array>} - Filtered chat records
     */
    async getAllRecords(filters = {}) {
        try {
            let collection = db.chats.toCollection();
            
            // Apply platform filter
            if (filters.platformId) {
                collection = collection.filter(chat => chat.platformId === filters.platformId);
            }
            
            // Apply date range filter
            if (filters.dateFrom || filters.dateTo) {
                collection = collection.filter(chat => {
                    if (filters.dateFrom && chat.timestamp < filters.dateFrom) return false;
                    if (filters.dateTo && chat.timestamp > filters.dateTo) return false;
                    return true;
                });
            }
            
            // Apply tag filter
            if (filters.tags && filters.tags.length > 0) {
                collection = collection.filter(chat => {
                    return filters.tags.some(tag => chat.tags.includes(tag));
                });
            }
            
            return await collection.reverse().sortBy('timestamp');
        } catch (error) {
            console.error('Error getting all records:', error);
            return [];
        }
    }

    /**
     * Export all records as JSON
     * @returns {Promise<string>} - JSON string of all records
     */
    async exportAsJSON() {
        try {
            const allRecords = await db.chats.toArray();
            return JSON.stringify(allRecords, null, 2);
        } catch (error) {
            console.error('Error exporting as JSON:', error);
            throw error;
        }
    }

    /**
     * Delete a chat record by ID
     * @param {string} id - The record ID to delete
     */
    async deleteRecord(id) {
        try {
            await db.chats.delete(id);
        } catch (error) {
            console.error('Error deleting record:', error);
            throw error;
        }
    }

    /**
     * Add canonical facts from habit-stack capture
     * @param {Object} factData - The fact data to store
     */
    async addCanonicalFact(factData) {
        try {
            const fact = {
                id: this.generateUUID(),
                chatId: factData.chatId,
                facts: factData.facts, // Array of 3 facts
                userLabel: factData.userLabel,
                timestamp: Date.now(),
                sessionCount: await this.getSessionCount() + 1
            };
            
            await db.facts.add(fact);
            return fact;
        } catch (error) {
            console.error('Error adding canonical fact:', error);
            throw error;
        }
    }

    /**
     * Get session count for habit streak
     */
    async getSessionCount() {
        try {
            return await db.facts.count();
        } catch (error) {
            console.error('Error getting session count:', error);
            return 0;
        }
    }

    /**
     * Check storage quota and warn if approaching limit
     */
    async checkQuota() {
        if (navigator.storage && navigator.storage.estimate) {
            try {
                const estimate = await navigator.storage.estimate();
                const usage = estimate.usage || 0;
                const quota = estimate.quota || 0;
                const percentUsed = usage / quota;
                
                if (percentUsed >= this.quotaWarningThreshold) {
                    console.warn(`Storage usage at ${(percentUsed * 100).toFixed(1)}%`);
                    return {
                        warning: true,
                        usage: usage,
                        quota: quota,
                        percentUsed: percentUsed
                    };
                }
                
                return {
                    warning: false,
                    usage: usage,
                    quota: quota,
                    percentUsed: percentUsed
                };
            } catch (error) {
                console.error('Error checking quota:', error);
                return null;
            }
        }
        return null;
    }

    /**
     * Generate UUID for record IDs
     */
    generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    /**
     * Extract title from first user message
     */
    extractTitle(exchanges) {
        if (!exchanges || exchanges.length === 0) return 'Untitled Chat';
        
        const firstUserMessage = exchanges.find(ex => ex.speaker === 'user');
        if (!firstUserMessage || !firstUserMessage.text) return 'Untitled Chat';
        
        // Take first 50 chars, add ellipsis if longer
        const title = firstUserMessage.text.substring(0, 50);
        return title.length < firstUserMessage.text.length ? title + '...' : title;
    }

    /**
     * Generate content snippet (first 200 chars)
     */
    generateSnippet(exchanges) {
        if (!exchanges || exchanges.length === 0) return '';
        
        // Concatenate all text from exchanges
        const allText = exchanges
            .map(ex => ex.text || '')
            .join(' ')
            .substring(0, 200);
        
        return allText.length < exchanges.map(ex => ex.text || '').join(' ').length 
            ? allText + '...' 
            : allText;
    }

    /**
     * Get storage statistics
     */
    async getStorageStats() {
        try {
            const chatCount = await db.chats.count();
            const factCount = await db.facts.count();
            const quota = await this.checkQuota();
            
            return {
                chatCount,
                factCount,
                quota
            };
        } catch (error) {
            console.error('Error getting storage stats:', error);
            return null;
        }
    }
}

// Export singleton instance
const storageManager = new StorageManager();
